(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{357:function(e,r,a){e.exports=a.p+"assets/img/huancun.7cceda73.png"},358:function(e,r,a){e.exports=a.p+"assets/img/cache1.83c8aa1b.png"},370:function(e,r,a){"use strict";a.r(r);var t=a(45),s=Object(t.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"浏览器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#浏览器"}},[e._v("#")]),e._v(" 浏览器")]),e._v(" "),t("h2",{attrs:{id:"一-缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一-缓存"}},[e._v("#")]),e._v(" 一 缓存")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.jianshu.com/p/54cc04190252",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考资料"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。")]),e._v(" "),t("p",[e._v("对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。")]),e._v(" "),t("p",[t("img",{attrs:{src:a(357),alt:"An image"}})]),e._v(" "),t("h3",{attrs:{id:"缓存位置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#缓存位置"}},[e._v("#")]),e._v(" 缓存位置")]),e._v(" "),t("p",[e._v("从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。")]),e._v(" "),t("ul",[t("li",[e._v("Service Worker")]),e._v(" "),t("li",[e._v("Memory Cache")]),e._v(" "),t("li",[e._v("Disk Cache")]),e._v(" "),t("li",[e._v("Push Cache")])]),e._v(" "),t("h4",{attrs:{id:"_1-service-worker"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-service-worker"}},[e._v("#")]),e._v(" 1.Service Worker")]),e._v(" "),t("p",[e._v("Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。")]),e._v(" "),t("p",[e._v("Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。")]),e._v(" "),t("p",[e._v("当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。")]),e._v(" "),t("h4",{attrs:{id:"_2-memory-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-memory-cache"}},[e._v("#")]),e._v(" 2.Memory Cache")]),e._v(" "),t("p",[e._v("Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。")]),e._v(" "),t("p",[e._v("虽然内存缓存比较高效，但是计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。")]),e._v(" "),t("p",[e._v("当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于memory cache 和disk cache;")]),e._v(" "),t("ul",[t("li",[e._v("从图中不难看出，memory cache读取速度极快，disk cache读取速度略慢\n"),t("img",{attrs:{src:a(358),alt:"img.png"}})])]),e._v(" "),t("h2",{attrs:{id:"二-使用service-worker实现前端性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二-使用service-worker实现前端性能优化"}},[e._v("#")]),e._v(" 二 使用service worker实现前端性能优化")]),e._v(" "),t("h2",{attrs:{id:"三-如何构建一个浏览器引擎"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三-如何构建一个浏览器引擎"}},[e._v("#")]),e._v(" 三 如何构建一个浏览器引擎")]),e._v(" "),t("h2",{attrs:{id:"四-preload和prefetch"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四-preload和prefetch"}},[e._v("#")]),e._v(" 四 preload和prefetch")])])}),[],!1,null,null,null);r.default=s.exports}}]);