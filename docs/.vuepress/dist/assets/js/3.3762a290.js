(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{357:function(e,a,r){e.exports=r.p+"assets/img/cache0.7cceda73.png"},358:function(e,a,r){e.exports=r.p+"assets/img/cache1.83c8aa1b.png"},359:function(e,a,r){e.exports=r.p+"assets/img/cache2.cd53c328.png"},360:function(e,a,r){e.exports=r.p+"assets/img/cache3.5deca31f.png"},361:function(e,a,r){e.exports=r.p+"assets/img/cache4.0628dadf.png"},362:function(e,a,r){e.exports=r.p+"assets/img/cache5.13840e98.png"},363:function(e,a,r){e.exports=r.p+"assets/img/cache6.f4a022fe.png"},383:function(e,a,r){"use strict";r.r(a);var t=r(45),s=Object(t.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[t("a",{attrs:{href:"https://www.jianshu.com/p/54cc04190252",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考资料-简书"),t("OutboundLink")],1),e._v(" "),t("br"),e._v(" "),t("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考资料-MDN HTTP CACHING"),t("OutboundLink")],1)]),e._v(" "),t("p",[e._v("缓存可以说是性能优化中简单高效的一种优化方式了。一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。")]),e._v(" "),t("p",[e._v("对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。")]),e._v(" "),t("p",[t("img",{attrs:{src:r(357),alt:"An image"}})]),e._v(" "),t("h2",{attrs:{id:"一-缓存位置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一-缓存位置"}},[e._v("#")]),e._v(" 一 缓存位置")]),e._v(" "),t("p",[e._v("从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。")]),e._v(" "),t("ul",[t("li",[e._v("Service Worker")]),e._v(" "),t("li",[e._v("Memory Cache")]),e._v(" "),t("li",[e._v("Disk Cache")]),e._v(" "),t("li",[e._v("Push Cache")])]),e._v(" "),t("h3",{attrs:{id:"_1-service-worker"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-service-worker"}},[e._v("#")]),e._v(" 1.Service Worker")]),e._v(" "),t("p",[e._v("Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS\n协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。")]),e._v(" "),t("p",[e._v("Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install\n事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。")]),e._v(" "),t("p",[e._v("当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache\n中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。")]),e._v(" "),t("h3",{attrs:{id:"_2-memory-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-memory-cache"}},[e._v("#")]),e._v(" 2.Memory Cache")]),e._v(" "),t("p",[e._v("Memory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源,例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快,内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭\nTab 页面，内存中的缓存也就被释放了。")]),e._v(" "),t("p",[e._v("虽然内存缓存比较高效，但是计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。")]),e._v(" "),t("p",[e._v("当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于memory cache 和disk cache;")]),e._v(" "),t("ul",[t("li",[e._v("从图中不难看出，memory cache读取速度极快，disk cache读取速度略慢\n"),t("img",{attrs:{src:r(358),alt:"img.png"}})])]),e._v(" "),t("p",[e._v("内存缓存中有一块重要的缓存资源是preloader相关指令（例如"),t("link",{attrs:{rel:"prefetch"}}),e._v("\n）下载的资源。总所周知preloader的相关指令已经是页面优化的常见手段之一，它可以一边解析js/css文件，一边网络请求下一个资源。")]),e._v(" "),t("p",[e._v("需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的HTTP缓存头Cache-Control是什么值，同时资源的匹配也并非仅仅是对URL做匹配，还可能会对Content-Type，CORS等其他特征做校验。")]),e._v(" "),t("h3",{attrs:{id:"_3-disk-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-disk-cache"}},[e._v("#")]),e._v(" 3.Disk Cache")]),e._v(" "),t("p",[e._v("Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。")]),e._v(" "),t("p",[e._v("在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder\n中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP\n的协议头中的缓存字段，我们会在下文进行详细介绍。")]),e._v(" "),t("p",[e._v("浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？ 关于这点，网上说法不一，不过以下观点比较靠得住：")]),e._v(" "),t("ul",[t("li",[e._v("对于大文件来说，大概率是不存储在内存中的，反之优先")]),e._v(" "),t("li",[e._v("当前系统内存使用率高的话，文件优先存储进硬盘")])]),e._v(" "),t("h3",{attrs:{id:"_4-push-cache"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-push-cache"}},[e._v("#")]),e._v(" 4.Push Cache")]),e._v(" "),t("p",[e._v("Push Cache（推送缓存）是 HTTP/2\n中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在Chrome浏览器中只有5分钟左右，同时它也并非严格执行HTTP头中的缓存指令。")]),e._v(" "),t("p",[e._v("如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。")]),e._v(" "),t("p",[e._v("那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。")]),e._v(" "),t("h2",{attrs:{id:"二-缓存策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二-缓存策略"}},[e._v("#")]),e._v(" 二 缓存策略")]),e._v(" "),t("p",[e._v("浏览器与服务器通信的方式为应答模式，即是：浏览器发起HTTP请求 –\n服务器响应该请求，那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。具体过程如下图:")]),e._v(" "),t("p",[t("img",{attrs:{src:r(359),alt:"An image"}})]),e._v(" "),t("p",[e._v("由上图我们可以知道：")]),e._v(" "),t("p",[e._v("浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识")]),e._v(" "),t("p",[e._v("浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中")]),e._v(" "),t("p",[e._v("以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了，本文也将围绕着这点进行详细分析。为了方便大家理解，这里我们根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是强缓存和协商缓存")]),e._v(" "),t("h3",{attrs:{id:"_1-强缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-强缓存"}},[e._v("#")]),e._v(" 1.强缓存")]),e._v(" "),t("p",[e._v("强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种\nHTTP Header 实现：Expires 和 Cache-Control。")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Expires - 缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age +\n请求时间，需要和Last-modified结合使用。Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。Expires 是 HTTP/1\n的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。")])]),e._v(" "),t("li",[t("p",[e._v("Cache-Control - 在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control:\nmax-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：")]),e._v(" "),t("p",[t("img",{attrs:{src:r(360),alt:"An image"}})])]),e._v(" "),t("li",[t("p",[e._v("两者同时存在的话，Cache-Control优先级高于Expires。在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。")])])]),e._v(" "),t("h3",{attrs:{id:"_2-协商缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-协商缓存"}},[e._v("#")]),e._v(" 2.协商缓存")]),e._v(" "),t("p",[e._v("协商缓存：协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("协商缓存生效，返回304和Not Modified")]),e._v(" "),t("p",[t("img",{attrs:{src:r(361),alt:"An image"}})])]),e._v(" "),t("li",[t("p",[e._v("协商缓存失效，返回200和请求结果")]),e._v(" "),t("p",[t("img",{attrs:{src:r(362),alt:"An image"}})])])]),e._v(" "),t("p",[e._v("协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Last-Modified和If-Modified-Since - 浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加\nLast-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header。浏览器下一次请求这个资源，浏览器检测到有\nLast-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since\n中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200")])]),e._v(" "),t("li",[t("p",[e._v("ETag和If-None-Match - Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)\n，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request\nheader里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET\n200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。")])]),e._v(" "),t("li",[t("p",[e._v("两者之间对比： 首先在精确度上，Etag要优于Last-Modified。\nLast-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。\n第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。 第三在优先级上，服务器校验优先考虑Etag。")])])]),e._v(" "),t("h2",{attrs:{id:"三-缓存机制"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三-缓存机制"}},[e._v("#")]),e._v(" 三 缓存机制")]),e._v(" "),t("p",[e._v("强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)\n，协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。具体流程图如下：")]),e._v(" "),t("p",[t("img",{attrs:{src:r(363),alt:"An image"}})]),e._v(" "),t("h2",{attrs:{id:"四-实际场景应用缓存策略"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四-实际场景应用缓存策略"}},[e._v("#")]),e._v(" 四 实际场景应用缓存策略")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("频繁变动的资源 - Cache-Control: no-cache")])]),e._v(" "),t("li",[t("p",[e._v("不常变化的资源 - Cache-Control: max-age=31536000")])])])])}),[],!1,null,null,null);a.default=s.exports}}]);